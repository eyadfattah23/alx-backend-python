# Python - Async Comprehension 
## Resources

### Read or watch:

* PEP 530 – Asynchronous Comprehensions
* What’s New in Python: Asynchronous Comprehensions / Generators [link](https://www.blog.pythonlibrary.org/2017/02/14/whats-new-in-python-asynchronous-comprehensions-generators/)
* [Type-hints for generators](https://stackoverflow.com/questions/42531143/how-to-type-hint-a-generator-in-python-3)

## Learning Objectives

At the end of this project, expected to be able to explain to anyone, without the help of Google:

* How to write an asynchronous generator
* How to use async comprehensions
* How to type-annotate generators

## Requirements
* All files will be interpreted/compiled on Ubuntu 18.04 LTS using python3 (version 3.7)
* All files should end with a new line
* The first line of all files should be exactly #!/usr/bin/env python3
* A README.md file, at the root of the folder of the project, is mandatory
* code should use the pycodestyle style (version 2.5.x)
* The length of files will be tested using wc
* All modules should have a documentation (python3 -c 'print(__import__("my_module").__doc__)')
* All functions should have a documentation (python3 -c 'print(__import__("my_module").my_function.__doc__)'
* A documentation is not a simple word, it’s a real sentence explaining what’s the purpose of the module, class or method (the length of it will be verified)
* All functions and coroutines must be type-annotated.



---

### 1. **How to Write an Asynchronous Generator**

An **asynchronous generator** is a special kind of function that yields values asynchronously. Just like a normal Python generator (which uses the `yield` keyword to return values one at a time), an asynchronous generator uses both `yield` and `await` to return values after some asynchronous operation.

**How it works:**
- An asynchronous generator function is defined using the `async def` keyword.
- Inside the function, you can use the `await` keyword to pause the execution for an asynchronous task.
- You use the `yield` keyword to return each value one at a time.
  
**Example:**

Let’s create an asynchronous generator that yields numbers after a delay:

```python
import asyncio

# Define an asynchronous generator
async def async_gen():
    for i in range(5):
        await asyncio.sleep(1)  # Simulate a delay
        yield i  # Yield the value after each delay

# Async function to use the generator
async def main():
    async for value in async_gen():  # Asynchronous iteration
        print(value)

# Run the async function
asyncio.run(main())
```

**Explanation:**
- `async_gen()` is an asynchronous generator that pauses for 1 second using `await asyncio.sleep(1)` and then yields a number.
- In `main()`, we use `async for` to iterate over the asynchronous generator.

This prints each value (0 to 4) one by one, with a 1-second delay between them.

---

### 2. **How to Use Async Comprehensions**

**Async comprehensions** allow you to use asynchronous generators or iterators inside list, set, dict comprehensions, or generator expressions. This means that you can use `async for` in comprehensions to gather values asynchronously.

**Example 1: Async List Comprehension**

Let’s build a list asynchronously from values generated by an asynchronous generator:

```python
import asyncio

# Define an asynchronous generator
async def async_gen():
    for i in range(5):
        await asyncio.sleep(1)
        yield i

# Async function to use async comprehensions
async def main():
    result = [i async for i in async_gen()]  # Async list comprehension
    print(result)

# Run the async function
asyncio.run(main())
```

**Explanation:**
- We are collecting values from the `async_gen()` generator into a list using the async comprehension syntax `[i async for i in async_gen()]`.
- The `async for` keyword allows the comprehension to wait for the generator to yield values asynchronously.

**Example 2: Async Set Comprehension with Filtering**

You can also use `async for` inside a set comprehension or dict comprehension, along with filtering conditions:

```python
import asyncio

# Define an asynchronous generator
async def async_gen():
    for i in range(5):
        await asyncio.sleep(1)
        yield i

# Async function to use async comprehensions with filtering
async def main():
    result = {i async for i in async_gen() if i % 2 == 0}  # Only even numbers
    print(result)

# Run the async function
asyncio.run(main())
```

This collects the **even numbers** generated by `async_gen()` into a set.

---

### 3. **How to Type-Annotate Generators**

Type annotations are a way to specify the expected types of variables and return values in your code. For generators, type annotations help specify the type of values yielded and the type returned when the generator completes.

For asynchronous generators, you typically use the `AsyncGenerator` type from the `typing` module.

**Type annotations for generators:**

1. **For Regular Generators**:
   - A regular generator that yields values of type `T` and returns a value of type `R` is annotated as `Generator[T, None, R]`.

2. **For Asynchronous Generators**:
   - An asynchronous generator that yields values of type `T` is annotated as `AsyncGenerator[T, None]`.

**Example: Type Annotation for an Asynchronous Generator**

Let’s add type annotations to an asynchronous generator that yields integers:

```python
import asyncio
from typing import AsyncGenerator

# Define an asynchronous generator with type annotations
async def async_gen() -> AsyncGenerator[int, None]:
    for i in range(5):
        await asyncio.sleep(1)
        yield i  # Yield an integer

# Async function to use the generator
async def main():
    async for value in async_gen():
        print(value)

# Run the async function
asyncio.run(main())
```

**Explanation:**
- The return type of the `async_gen()` function is `AsyncGenerator[int, None]`. 
  - `int` represents the type of values the generator yields.
  - `None` represents the "sent" values (not used in most cases for asynchronous generators).
  
**How it works:**
- This annotation tells Python that the function is an asynchronous generator that yields integers.

**Typing with `await` in Comprehensions**:

You can also use type annotations in async comprehensions. Let’s type-annotate a function using async list comprehension:

```python
from typing import List

# Async function that returns a list of integers
async def collect_values() -> List[int]:
    result = [i async for i in async_gen()]  # Collect into a list
    return result
```

Here, the `collect_values()` function returns a `List[int]`, meaning it returns a list of integers collected from an asynchronous comprehension.

---

### Summary

1. **Asynchronous Generators**: These generators use `yield` to return values asynchronously and must be defined with `async def`. They are useful when you want to yield values one by one with some delay or asynchronous operation.

2. **Async Comprehensions**: You can use `async for` inside comprehensions (list, set, dict comprehensions, and generator expressions) to work with asynchronous generators or iterators in a concise manner.

3. **Type Annotations**: For asynchronous generators, you use `AsyncGenerator` from `typing` to specify the type of values being yielded and sent. For comprehensions, you can type them as regular lists, sets, or dictionaries but with asynchronous processing inside.

---


### **Synchronous vs. Asynchronous Execution**

1. **Synchronous Execution (Your Example)**
   ```python
    import time

    def sync_gen():
        for i in range(5):
            time.sleep(1)  # Simulate a delay (blocking)
            yield i  # Yield the value after each delay

    def main():
        for value in sync_gen(): 
            print(value)

    main()
   ```

   **How it works:**
   - `time.sleep(1)` introduces a delay in each iteration of the loop.
   - Since the `for` loop inside `sync_gen()` is **synchronous**, each iteration of the loop **blocks** the main thread until the delay is over.
   - The `main()` function is blocked during each call to `time.sleep(1)`.

   **Characteristics:**
   - This is fine if you just want the generator to run on a single thread without multitasking.
   - The code will execute one step at a time, and while it’s sleeping, **no other tasks** can run. The program is essentially "stuck" during the sleep.

2. **Asynchronous Execution (Using `async def`)**
   ```python
    import asyncio

    async def async_gen():
        for i in range(5):
            await asyncio.sleep(1)  # Simulate a delay (non-blocking)
            yield i  # Yield the value after each delay

    async def main():
        async for value in async_gen(): 
            print(value)

    asyncio.run(main())
   ```

   **How it works:**
   - `await asyncio.sleep(1)` introduces a delay **without blocking** the main thread.
   - The `await` keyword means that while the code is waiting for 1 second to pass, other tasks can run. This is the key difference.
   - `async for` allows you to iterate through the values generated by `async_gen()` asynchronously, meaning the main thread is free to do other work during delays.

   **Characteristics:**
   - The code is non-blocking, which means the program can perform other tasks while it is waiting for the sleep to finish.
   - This is useful when you want your program to handle multiple tasks concurrently (e.g., making multiple API requests, handling I/O operations, etc.).

### **Key Differences**:

1. **Blocking vs. Non-blocking**:
   - **Synchronous** (`time.sleep`) blocks the program execution. If your generator has a delay, the program is "stuck" waiting during that delay.
   - **Asynchronous** (`await asyncio.sleep`) doesn’t block the program. While waiting, it can switch to other tasks, making the program more efficient.

2. **Concurrency**:
   - In the synchronous version, each iteration of the loop must finish before moving to the next.
   - In the asynchronous version, the program can switch between multiple tasks, allowing other operations (like handling network requests or reading from files) to continue while waiting for each delay to complete.

### Example of a Practical Use of Asynchronous Generators:

Imagine you want to make multiple API calls. If you use a synchronous approach, each API call will block the program until it completes. However, with asynchronous code, while waiting for one API to respond, you can start fetching from another one.

**Example: Asynchronous API Requests**

```python
import asyncio
import random

# Simulate API requests
async def fetch_data(id: int) -> str:
    await asyncio.sleep(random.uniform(0.5, 2))  # Simulate varying response times
    return f"Data from API {id}"

# Asynchronous generator that fetches data from multiple APIs
async def async_gen():
    for i in range(5):
        result = await fetch_data(i)
        yield result

# Async function to consume the generator
async def main():
    async for value in async_gen():
        print(value)

asyncio.run(main())
```

**How it works:**
- Each call to `fetch_data` doesn’t block the program. So, while waiting for one API response, others can be requested.
- This allows you to fetch data concurrently from multiple APIs.

In contrast, if this was done synchronously, the program would wait for each API call to finish before starting the next one, which would be much slower.

### What Happens if You Don’t Use `async`?

To answer your specific question:

1. **Your synchronous code will run fine**, but it will block the program during each `time.sleep(1)`, preventing any other tasks from running during that time.
2. **You can’t run multiple asynchronous tasks together** (e.g., fetching data from multiple sources, or handling I/O efficiently) in a synchronous generator.
3. **Using async is beneficial when you want concurrency**, as it allows your program to switch between tasks during wait periods without being stuck.

### Conclusion

- If you’re writing code where delays or waiting times block the program and you don’t care about multitasking, then a synchronous generator is fine.
- But if you want **concurrent** execution, where the program can do other work while waiting for tasks to finish, you should use **asynchronous generators**.
